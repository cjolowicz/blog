--- 
date: 2019-11-07T12:52:59+02:00
title: "The hypermodern Python project"
description: "Coding in Python like Savielly Tartakower."
draft: true
tags:
  - python
  - poetry
  - nox
  - GitHub Actions
  - pytest
  - coverage.py
  - Codecov
  - PyPI
  - black
  - pyenv
  - flake8
  - click
---

Welcome to the whirlwind tour of the Python ecosystem in late 2019!

[Python 3.8](https://docs.python.org/3/whatsnew/3.8.html) has been officially
released this month, and the [Python 2
sunset](https://www.python.org/doc/sunset-python-2/) will occur on new year
2020, after more than a decade of coexistence with Python 3.

The Python landscape has changed drastically over the last decade, with a host
of new tools and best practices improving the Python developer experience. At
the same time, their adoption has lagged behind, due to the constraints of
legacy support. Time to show how to build a Python project for
*hypermodernists*, from scratch.

This post is aimed both at beginners who are keen to learn best practises from
the start, and seasoned Python developers whose workflows are affected by
boilerplate and workarounds required by the legacy toolbox. The focus is on
simplicity and minimalism.

<!--
This post has a companion repository:
[cjolowicz/hypermodern-python](https://github.com/cjolowicz/hypermodern-python)
-->

> *You need a recent Linux, Unix, or Mac system with
> [bash](https://www.gnu.org/software/bash/), [curl](https://curl.haxx.se) and
> [git](https://www.git-scm.com) for this tutorial.*

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Setting up a GitHub repository](#setting-up-a-github-repository)
- [Installing Python with pyenv](#installing-python-with-pyenv)
- [Setting up a Python project using Poetry](#setting-up-a-python-project-using-poetry)
- [Creating a package in src layout](#creating-a-package-in-src-layout)
- [Managing virtual environments with Poetry](#managing-virtual-environments-with-poetry)
- [Managing dependencies with Poetry](#managing-dependencies-with-poetry)
- [Command-line interfaces with click](#command-line-interfaces-with-click)
- [Unit testing with pytest](#unit-testing-with-pytest)
- [Code coverage with coverage.py](#code-coverage-with-coverage-py)
- [Test automation with Nox](#test-automation-with-nox)
- [Linting with flake8](#linting-with-flake8)
- [Code formatting with Black](#code-formatting-with-black)
- [Continuous integration using GitHub Actions](#continuous-integration-using-github-actions)
- [Coverage reporting with Codecov](#coverage-reporting-with-codecov)
- [Uploading your package to PyPI](#uploading-your-package-to-pypi)
- [A typical release process](#a-typical-release-process)
- [Conclusion](#conclusion)

<!-- markdown-toc end -->

## Setting up a GitHub repository

In this guide, [GitHub](https://github.com) is used to host the public git
repository for your project. Other popular options are
[GitLab](https://gitlab.com/) and [BitBucket](https://bitbucket.org/). Create a
repository, and populate it with `README.md` and `LICENSE` files. For this
project, I will use the [MIT license](https://choosealicense.com/licenses/mit/),
a simple permissive license.

> *Throughout this guide, replace `hypermodern-python` with the name of your own
> repository. Choose a different name to avoid a name collision on PyPI.*

Clone the repository to your machine, and `cd` into it:

```sh
git clone git@github.com:<your-username>/hypermodern-python.git
cd hypermodern-python
```

As you follow the rest of this guide, create a series of [small, atomic
commits](https://deepsource.io/blog/git-best-practices/) documenting your steps.
Use `git status` to discover files generated by commands shown in the guide.

## Installing Python with pyenv

Let's continue by setting up the developer environment. First you need to get a
recent Python. Don't bother with package managers or official binaries. The tool
of choice is [pyenv](https://github.com/pyenv/pyenv), a Python version manager.
Install it like this:

```sh
curl https://pyenv.run | bash
```

Add the following lines to your `~/.bashrc`:

```sh
export PATH="~/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"
```

Open a new shell, or source `~/.bashrc` in your current shell:

```sh
source ~/.bashrc
```

Install the Python build dependencies for your platform, using one of the
commands listed in the [official
instructions](https://github.com/pyenv/pyenv/wiki/Common-build-problems). For
example, on a recent [Ubuntu](https://ubuntu.com) this would be:

```sh
sudo apt update && sudo apt install -y make build-essential libssl-dev zlib1g-dev \
libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev \
libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python-openssl git
```

You're ready to install the latest Python releases. This may take a while:

```sh
pyenv install 3.8.0
pyenv install 3.7.5
```

Make your fresh Pythons available inside the repository:

```sh
pyenv local 3.8.0 3.7.5
```

Congratulations! You have access to the latest and greatest of Python:

```sh
$ python --version
Python 3.8.0

$ python3.7 --version
Python 3.7.5
```

Python 3.8.0 is the default version and can be invoked as `python`, but both
versions are accessible as `python3.7` and `python3.8`, respectively.

## Setting up a Python project using Poetry

[Poetry](https://poetry.eustace.io) is a tool to manage Python packaging and
dependencies. Its ease of use and support for modern workflows make it the ideal
successor to the venerable [setuptools](http://setuptools.readthedocs.io). It is
similar to `npm` and `yarn` in the JavaScript world, and to other modern package
and dependency managers.

With Poetry 1.0 [around the
corner](https://github.com/sdispater/poetry/projects/1), I would recommend you
install the preview version:

```sh
curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py |
POETRY_PREVIEW=1 python
```

Open a new login shell or source `~/.poetry/env` in your current shell:

```sh
source ~/.poetry/env
```

Initialize your Python project:

```sh
poetry init --no-interaction  # short option: -n
```

This command will create a `pyproject.toml` file, the new Python package
configuration file specified in [PEP
517](https://www.python.org/dev/peps/pep-0517/) and
[518](https://www.python.org/dev/peps/pep-0518/).

```toml
[tool.poetry]
name = "hypermodern-python"
version = "0.1.0"
description = ""
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.8"

[tool.poetry.dev-dependencies]

[build-system]
requires = ["poetry>=0.12"]
build-backend = "poetry.masonry.api"
```

There you go: One declarative file in [TOML](https://github.com/toml-lang/toml)
syntax, containing the entire package configuration.

Poetry added a dependency on Python 3.8, because this is the Python version you
ran it in. Support the previous release as well by changing this to Python 3.7:

```toml
[tool.poetry.dependencies]
python = "^3.7"
```

Let's also add some metadata to the package:

```toml
[tool.poetry]
...
license = "MIT"
readme = "README.md"
homepage = "https://github.com/<your-username>/hypermodern-python"
repository = "https://github.com/<your-username>/hypermodern-python"
keywords = ["hypermodern"]
```

## Creating a package in src layout

Let's create an initial skeleton package. You should organize your package in
[src layout](https://hynek.me/articles/testing-packaging/), like this:

```sh
.
├── pyproject.toml
└── src
    └── hypermodern_python
        └── __init__.py

2 directories, 2 files
```

The source file contains only a version declaration:

```python
# src/hypermodern_python/__init__.py
__version__ = "0.1.0"
```

Use [snake-case](https://en.wikipedia.org/wiki/Snake_case) for the package name
`hypermodern_python`, as opposed to the
[kebab-case](https://en.wiktionary.org/wiki/kebab_case) used for the repository
name `hypermodern-python`. In other words, take your repository name and replace
hyphens by underscores.

> Replace hypermodern-python with the name of your own repository, to avoid a
> name collision on PyPI.

## Managing virtual environments with Poetry

A [virtual environment](https://docs.python.org/3/tutorial/venv.html) gives your
project an isolated runtime environment, consisting of a specific Python version
and an independent set of installed Python packages. This way, the dependencies
of your current project do not interfere with the system-wide Python
installation, or other projects you're working on.

Poetry manages virtual environments for your projects. To see this in action,
install the skeleton package using Poetry:

```sh
$ poetry install

Creating virtualenv hypermodern-python-rLESuZJY-py3.8 in …/pypoetry/virtualenvs
Updating dependencies
Resolving dependencies... (0.1s)

Writing lock file

Nothing to install or update

  - Installing hypermodern-python (0.1.0)
```

Poetry created a virtual environment dedicated to your project, and installed
your initial package into it. It also created a so-called *lock file*, named
`poetry.lock`. You will learn more about this file in the next section.

Let's run a Python session inside the new virtualenv:

```python
$ poetry run python

Python 3.8.0 (default, Oct 16 2019, 19:27:04)
[GCC 8.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import hypermodern_python
>>> hypermodern_python.__version__
'0.1.0'
>>>
```

## Managing dependencies with Poetry

Let's install the first dependency, the
[click](https://click.palletsprojects.com/) package. This Python package allows
you to create beautiful command-line interfaces in a composable way with as
little code as necessary.

```sh
$ poetry add click

Using version ^7.0 for click

Updating dependencies
Resolving dependencies... (0.1s)

Writing lock file


Package operations: 1 install, 0 updates, 0 removals

  - Installing click (7.0)
```

Several things are happening here:

- The package is downloaded and installed into the virtual environment.
- The installed version is added to the lock file `poetry.lock`.
- A more general version constraint is added to `pyproject.toml`.

The dependency entry in `pyproject.toml` contains a [version
constraint](https://poetry.eustace.io/docs/versions/) for the installed package:
`^7.0`. This means that users of the package need to have at least the current
release, `7.0`. They can also have a newer release, as long as it doesn't
contain breaking changes. You can edit this version constraint, for example if a
package you depend on does not follow the [Semantic
Versioning](https://semver.org/) scheme.

By contrast, `poetry.lock` contains the exact version of `click` installed into
the virtual environment. Place this file under source control. It allows
everybody in your team to work with the same environment. It also helps you to
[keep production and development environments as similar as
possible](https://12factor.net/dev-prod-parity).

Upgrading the dependency to a new minor or patch release is now as easy as this:

```sh
poetry update click
```

To upgrade to a new major release, you need to update the version constraint
explicitly. Coming from the previous major release of `click`, you could use the
following command to upgrade to `7.0`:

```sh
poetry add click^7.0
```

## Command-line interfaces with click

Time to add some actual code to the package. As you may have guessed, we're
going to create a console application using `click`:

```python
# src/hypermodern_python/console.py
import click

from . import __version__


@click.command()
@click.version_option(version=__version__)
def main():
    """The hypermodern Python project."""
```

The `console` module defines a minimal command-line application, supporting
`--help` and `--version` options.

Register the script in `pyproject.toml`:

```toml
[tool.poetry.scripts]
hypermodern-python = "hypermodern_python.console:main"
```

Finally, install the package into the virtual environment:

```sh
poetry install
```

You can now run the script like this:

```sh
$ poetry run hypermodern-python -- --help

Usage: hypermodern-python [OPTIONS]

  The hypermodern Python project.

Options:
  --version  Show the version and exit.
  --help     Show this message and exit.
```

## Unit testing with pytest

It's never too early to add unit tests to a project. While the
[unittest](https://docs.python.org/3/library/unittest.html) framework is part of
the Python standard library, [pytest](https://docs.pytest.org/en/latest/) has
become somewhat of a *de facto* standard. Let's add this package as a
development dependency, using Poetry's `--dev` option:

```sh
poetry add --dev pytest
```

Organize tests in a [separate file
hierarchy](http://doc.pytest.org/en/latest/goodpractices.html#tests-outside-application-code)
next to `src`, named `tests`:

```sh
tests
├── __init__.py
└── test_console.py

1 directory, 2 files
```

The file `__init__.py` is empty and serves to declare the test suite as a
package. `test_console.py` contains a test case for the `console` module, as
well as a test fixture:

```python
# tests/test_console.py
import click.testing
import pytest

from hypermodern_python import console


@pytest.fixture
def runner():
    return click.testing.CliRunner()


def test_help_succeeds(runner):
    result = runner.invoke(console.main, ["--help"])
    assert result.exit_code == 0
```

Invoke `pytest` to run the test suite:

```python
$ poetry run pytest
============================ test session starts =============================
platform linux -- Python 3.8.0, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /hypermodern-python
collected 1 item

tests/test_console.py .                                                 [100%]

============================= 1 passed in 0.03s ==============================
```

## Code coverage with coverage.py

*Code coverage* is a measure of the degree to which the source code of your
program is executed while running its test suite. The code coverage of Python
programs can be determined using a tool called
[Coverage.py](https://coverage.readthedocs.io/). Install it via the
[pytest-cov](https://pytest-cov.readthedocs.io/en/latest/) plugin, which
integrates Coverage.py with `pytest`:

```sh
poetry add --dev pytest-cov
```

Create the `.coveragerc` configuration file to
teach the tool about your source tree layout. The configuration also enables
branch analysis and the display of line numbers for missing coverage.

```ini
# .coveragerc
[paths]
source =
   src
   */site-packages

[run]
branch = true
source = hypermodern_python

[report]
show_missing = true
```

To enable coverage reporting, invoke `pytest` with the `--cov` option:

```python
$ poetry run pytest -- --cov
============================= test session starts ==============================
platform linux -- Python 3.8.0, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /hypermodern-python
plugins: cov-2.8.1
collected 1 item

tests/test_console.py .                                                 [100%]

--------------- coverage: platform linux, python 3.8.0-final-0 -----------------
Name                                 Stmts   Miss Branch BrPart  Cover   Missing
--------------------------------------------------------------------------------
src/hypermodern_python/__init__.py       1      0      0      0   100%
src/hypermodern_python/console.py        5      0      0      0   100%
--------------------------------------------------------------------------------
TOTAL                                    6      0      0      0   100%
============================== 1 passed in 0.09s ===============================
```

## Test automation with Nox

One of my personal favorites, [nox](https://nox.thea.codes/) is a successor to
the venerable [tox](https://tox.readthedocs.io/). At its core, the tool
automates testing in multiple Python environments. It makes it easy to run any
kind of job in an isolated environment, with only those dependencies installed
that the particular job needs.

Install Nox via [pip](https://pip.readthedocs.org/):

```sh
pip install --user --upgrade nox
```

Unlike tox, Nox uses a standard Python file for configuration:

```python
# noxfile.py
import nox


@nox.session(python=["3.8", "3.7"])
def tests(session):
    """Run the test suite."""
    env = {"VIRTUAL_ENV": session.virtualenv.location}
    session.run("poetry", "install", external=True, env=env)
    session.run("pytest", "--cov", *session.posargs)
```

> [This PR](https://github.com/theacodes/nox/pull/245) relieves the need to
> explicitly pass `VIRTUAL_ENV` to Poetry. It has been merged into master and
> will be available with the upcoming Nox release.

This file defines a session named `tests`, which installs the project
dependencies and runs the test suite. Nox will create a virtualenv for each of
the listed Python versions (3.8 and 3.7), and run the session inside each
virtualenv.

```python
$ nox

nox > Running session tests-3.8
nox > Creating virtual environment (virtualenv) using python3.8 in .nox/tests-3-8
nox > poetry install
...
nox > pytest --cov
...
nox > Session tests-3.8 was successful.
nox > Running session tests-3.7
nox > Creating virtual environment (virtualenv) using python3.7 in .nox/tests-3-7
nox > poetry install
...
nox > pytest --cov
...
nox > Session tests-3.7 was successful.
nox > Ran multiple sessions:
nox > * tests-3.8: success
nox > * tests-3.7: success
```

Nox recreates the virtualenv from scratch at each invocation (a sensible
default). You can speed things up by passing the `--reuse-existing-virtualenvs
(-r)` option:

```sh
nox -r
```

## Linting with flake8

Linters analyze source code to flag programming errors, bugs, stylistic errors,
and suspicious constructs. The most common ones for Python are
[pylint](https://www.pylint.org) and [flake8](http://flake8.pycqa.org). Add a
second Nox session to your `noxfile.py`, to run `flake8` on your codebase:

```python
# noxfile.py
import nox


locations = "src", "tests", "noxfile.py"


@nox.session(python=["3.8", "3.7"])
def lint(session):
    """Lint using flake8."""
    session.install("flake8")
    session.run("flake8", *locations)

...
```

Configure `flake8` using the `.flake8` configuration file:

```ini
# .flake8
[flake8]
select = C,E,F,W
max-complexity = 10
```

`flake8` assigns each of its messages an error code, prefixed by one or more
letters. These prefixes group the errors into so-called violation classes. The
`select` option above enables all the built-in violation classes:

- `F` are errors reported by [pyflakes](https://github.com/PyCQA/pyflakes), a
  tool which parses source files and finds invalid Python code.
- `W` and `E` are warnings and errors reported by
  [pycodestyle](https://github.com/pycqa/pycodestyle), which checks your Python
  code against some of the style conventions in [PEP
  8](http://www.python.org/dev/peps/pep-0008/).
- `C` are violations reported by [mccabe](https://github.com/PyCQA/mccabe),
  which checks the code complexity of your Python package against the limit
  specified via the `max-complexity` option.

By default, Nox runs all sessions defined in `noxfile.py`, but we can restrict
it to the lint session using the `--session (-s)` option:

```sh
nox -rs lint
```

There are many [awesome flake8
extensions](https://github.com/DmytroLitvinov/awesome-flake8-extensions). Some
of these will be presented in later sections.

## Code formatting with Black

The next addition to our toolbox is [Black](https://github.com/psf/black), the
uncompromising Python code formatter. One of its greatest features is its lack
of configurability. Blackened code looks the same regardless of the project
you're reading.

Adding Black is straightforward:

```python
# noxfile.py
...

@nox.session(python="3.8")
def black(session):
    """Run black code formatter."""
    session.install("black")
    session.run("black", *locations)
```

With the Nox session in place, you can reformat your code like this:

```sh
nox -rs black
```

Checking adherence to the Black code style within `nox` is nice, but you don't
want it to reformat your source code unless you explicitly ask for it. As the
first step, exclude Black from the sessions run by default, by setting
`nox.options.sessions`:

```python
# noxfile.py
import nox


nox.options.sessions = "lint", "tests"
...
```

Next, check adherence to the Black code style as part of the linter session,
without actually performing any formatting. This can be done using the
[flake8-black](https://pypi.org/project/flake8-black/) plugin:

```python
# noxfile.py
...
def lint(session):
    ...
    session.install("flake8", "flake8-black")
    ...
```

Finally, configure `flake8` to enable the `flake8-black` warnings, which are
prefixed by `BLK`. Also, some built-in warnings do not align well with Black.
Ignore `E203` (Whitespace before ':'), and `W503` (Line break before binary
operator), and set the maximum line length to a more permissive value:

```ini
# .flake8
[flake8]
select = BLK,C,E,F,W
ignore = E203,W503
max-line-length = 88
...
```

## Continuous integration using GitHub Actions

Continuous integration (CI) refers to the practice of automating the integration
of code changes into a software project. The CI process can trigger tools such
as unit tests, linters, or typecheckers to verify the correctness of the
changes.

You have a plethora of options when it comes to continuous integration.
Traditionally, many open-source projects have employed [Travis
CI](https://travis-ci.com). Another popular choice are Microsoft's [Azure
Pipelines](https://azure.microsoft.com/en-us/services/devops/pipelines/). In
this guide, you are going to use GitHub's brand new offering, [GitHub
Actions](https://github.com/features/actions).

Configure GitHub Actions by adding the following [YAML](https://yaml.org) file
to the `.github/workflows` directory:

```yaml
# .github/workflows/main.yml
name: tests
on: push
jobs:
  test:
    name: nox
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@1.0.0
    - uses: excitedleigh/setup-nox@0.1.0
    - uses: dschep/install-poetry-action@v1.2
      with:
        preview: true
    - run: nox
```

This file defines a so-called *workflow*, which is triggered on every push to
your GitHub repository, and runs on the latest supported Ubuntu image. The
workflow consists of four steps:

1. Use [actions/checkout](https://github.com/actions/checkout) to fetch and check out your code.
2. Use [excitedleigh/setup-nox](https://github.com/excitedleigh/setup-nox) to activate Python and install Nox.
3. Use [dschep/install-poetry-action](https://github.com/dschep/install-poetry-action) to install Poetry.
4. Invoke `nox` to run your test suite.

You can add a GitHub Actions badge to your repository page:

> [![tests](https://github.com/cjolowicz/hypermodern-python/workflows/tests/badge.svg)](https://github.com/cjolowicz/hypermodern-python/actions?workflow=tests)

Add the line below to the top of your `README.md` to get the badge:

```markdown
[![tests](https://github.com/<your-username>/hypermodern-python/workflows/tests/badge.svg)](https://github.com/<your-username>/hypermodern-python/actions?workflow=tests)
```

## Coverage reporting with Codecov

Let's also display code coverage right on your GitHub repository page. We will
use [Codecov](https://codecov.io/) for this; another common option is
[Coveralls](https://coveralls.io/). Sign up at Codecov, install the GitHub app,
and add your repository to Codecov. The sign up process will guide you through
these steps.

Add the Nox session shown below. This session exports the coverage data to
[cobertura](https://cobertura.github.io/cobertura/) XML format, which is the
format expected by Codecov. It then uses the official
[codecov CLI](https://github.com/codecov/codecov-python) to upload the coverage
data.

```python
# noxfile.py
...

@nox.session(python="3.7")
def coverage(session):
    """Upload coverage data."""
    session.install("coverage", "codecov")
    session.run("coverage", "xml")
    session.run("codecov", *session.posargs)
```

Next, grant GitHub Actions access to upload to Codecov. On Codecov, copy the
*Repository Upload Token* from the settings page of your repository. On GitHub,
go to the settings page of your repository, and add a secret named
`CODECOV_TOKEN` with the token you copied.

Invoke the session from the GitHub Actions workflow, providing the
`CODECOV_TOKEN` secret as an environment variable:

```yaml
# .github/workflows/main.yml
name: tests
on: push
jobs:
  test:
    name: nox
    runs-on: ubuntu-latest
    steps:
...
    - run: nox
    - run: nox -e coverage
      env:
        CODECOV_TOKEN: ${{secrets.CODECOV_TOKEN}}
```

Finally, add the Codecov badge to your `README.md`:

```markdown
[![Codecov](https://codecov.io/gh/<your-username>/hypermodern-python/branch/master/graph/badge.svg)](https://codecov.io/gh/<your-username>/hypermodern-python)
```

The badge looks like this:

> [![Codecov](https://codecov.io/gh/cjolowicz/hypermodern-python/branch/master/graph/badge.svg)](https://codecov.io/gh/cjolowicz/hypermodern-python)

## Uploading your package to PyPI

[PyPI](https://pypi.org/) is the official Python package registry, also known by
its affectionate nickname "[the Cheese
Shop](https://en.wikipedia.org/wiki/Cheese_Shop_sketch)". Uploading your package
to PyPI allows others to install it with [pip](https://pip.readthedocs.org/),
like so:

```sh
pip install hypermodern-python
```

Sign up at PyPI, and generate an API token on the Account Settings page. This
token permits GitHub Actions to upload packages to your PyPI account. Go to your
repository settings on GitHub, and add the token as a secret named `PYPI_TOKEN`.

Add the following lines to the bottom of your GitHub workflow:

```yaml
# .github/workflows/main.yml
...
    - run: poetry build
    - if: github.event_name == 'push' && startsWith(github.event.ref, 'refs/tags')
      run: |
        poetry publish --username=__token__ --password=${{ secrets.PYPI_TOKEN }}
```

You can now trigger package uploads by pushing a release tag to GitHub. In
addition to this, the package is built on every push to GitHub, for testing
purposes.

Add a badge to your `README.md` which links to your PyPI project page and always
displays the latest release:

```markdown
[![PyPI](https://img.shields.io/pypi/v/hypermodern-python.svg)](https://pypi.org/project/hypermodern-python/)
```

The badge looks like this: 
[![PyPI](https://img.shields.io/pypi/v/hypermodern-python.svg)](https://pypi.org/project/hypermodern-python/)

## A typical release process

Let's walk through the entire process of creating a release.

1. **Bump the version**

    Skip this step if you are releasing the initial version of your package.
    Otherwise, use Poetry to update the version declared in `pyproject.toml`:

    ```sh
    poetry version <version>  # for example: "major", "minor", "patch", "0.2.1"
    ```

    Don't forget to also update the version in your package's `__init__.py`.

2. **Update the changelog**

    The second step is to document the release. For example, add a
    `CHANGELOG.md` file to your repository, using the format specified at [Keep
    a Changelog](https://keepachangelog.com/).

3. **Push a release tag**

    The third step is to create and push an annotated Git tag. By convention,
    these tags have the form `v<version>`.

    ```sh
    git tag --message="hypermodern-python 1.0.0" v1.0.0
    git push --follow-tags
    ```

## Conclusion

Thank you for reading this far.

This article is dedicated to my father who introduced me to programming in the
1980s, and who is an avid chess book collector. I saw a copy of *Die
hypermoderne Schachpartie* (The hypermodern chess game) in his bookshelf,
written by [Savielly
Tartakower](https://en.wikipedia.org/wiki/Savielly_Tartakower) in 1925 to
modernize chess theory. That inspired the title of this blog post.
