--- 
date: 2019-10-16T09:12:59+02:00
title: "The hypermodern Python project"
description: "Coding in Python like Savielly Tartakower."
draft: true
tags:
  - python
  - poetry
  - nox
  - GitHub Actions
  - pytest
  - coverage.py
  - Codecov
  - PyPI
  - black
  - pyenv
---

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Setting up a repository on GitHub](#setting-up-a-repository-on-github)
- [Installing Python with pyenv](#installing-python-with-pyenv)
- [Setting up a Python project using Poetry](#setting-up-a-python-project-using-poetry)
- [Managing dependencies with Poetry](#managing-dependencies-with-poetry)
- [Creating a command-line interface with click](#creating-a-command-line-interface-with-click)
- [Adding unit tests with pytest](#adding-unit-tests-with-pytest)
- [Measuring code coverage with coverage.py](#measuring-code-coverage-with-coveragepy)
- [Using nox for test automation](#using-nox-for-test-automation)
- [Linting with flake8](#linting-with-flake8)
- [Code formatting with Black](#code-formatting-with-black)
- [Static type checking with pytype](#static-type-checking-with-pytype)
- [Supporting continuous integration using GitHub Actions](#supporting-continuous-integration-using-github-actions)
- [Coverage reporting with Codecov](#coverage-reporting-with-codecov)
- [Uploading your package to PyPI](#uploading-your-package-to-pypi)
- [A typical release process](#a-typical-release-process)
- [Creating documentation with Sphinx](#creating-documentation-with-sphinx)
- [Hosting documentation at Read the Docs](#hosting-documentation-at-read-the-docs)

<!-- markdown-toc end -->

Welcome to the *tour de force* of the Python ecosystem in late 2019!

Python 3.8 has been officially released this week, and the Python 2 sunset is
scheduled for new year 2020.

The Python landscape has changed drastically over the last decade, with a host
of new tools and best practices improving the Python developer experience. Time
to show how to build a Python project for hypermodernists, from scratch.

This post is aimed both at beginners who are keen to learn best practises from
the start, and seasoned Python developers whose workflows are still determined
by the boilerplate and workarounds associated with the legacy toolbox. The focus
is on simplicity and minimalism.

> *You need a recent Linux, Unix, or Mac system with
> [bash](https://www.gnu.org/software/bash/), [curl](https://curl.haxx.se) and
> [git](https://www.git-scm.com) for this tutorial.*

## Setting up a repository on GitHub

Create an empty repository on [GitHub](https://github.com). You can do this on
the GitHub website, or entirely from the console using the excellent
[hub](https://github.com/github/hub) tool:

```sh
mkdir hypermodern-python-project
cd hypermodern-python-project
hub init -g
hub create --description="The hypermodern Python project"
```

If you created the repository on the GitHub website, clone the repository to
your machine, and `cd` into it.

```sh
git clone git@github.com:<your-username>/hypermodern-python-project.git
cd hypermodern-python-project
```

> As you follow the rest of this tutorial, create a series of [small, atomic
> commits](https://deepsource.io/blog/git-best-practices/) documenting your
> steps. Use `git status` to discover files generated by commands shown in the
> tutorial. As a general rule, generated files should be added to the
> `.gitignore` file. Some files should be placed under source control instead;
> this will be pointed out below.

## Installing Python with pyenv

Let's continue by setting up the developer environment. First you need to get a
recent Python. Don't bother with package managers or official binaries. The tool
of choice is [pyenv](https://github.com/pyenv/pyenv), a Python version manager.
Install it like this:

```sh
curl https://pyenv.run | bash
```

Add the following lines to your `~/.bashrc`:

```sh
export PATH="~/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"
```

Open a new shell, or source `~/.bashrc` in your current shell:

```sh
source ~/.bashrc
```

Install the Python build dependencies for your platform, using one of the
commands listed in the [official
instructions](https://github.com/pyenv/pyenv/wiki/Common-build-problems). For
example, on a recent Ubuntu this would be:

```sh
sudo apt update && sudo apt install -y make build-essential libssl-dev zlib1g-dev \
libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev \
libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python-openssl git
```

You're ready to install the latest Python releases. This may take a while:

```sh
pyenv install 3.8.0
pyenv install 3.7.5
```

Make your fresh Pythons available inside the repository:

```sh
pyenv local 3.8.0 3.7.5
```

Congratulations! You have access to the latest and greatest of Python:

```sh
$ python --version
Python 3.8.0

$ python3.7 --version
Python 3.7.5
```

Python 3.8.0 is the default version and can be invoked as `python`, but both
versions are accessible as `python3.7` and `python3.8`, respectively.

## Setting up a Python project using Poetry

[Poetry](https://poetry.eustace.io) is a tool to manage Python packaging and
dependencies. Its ease of use and support for modern workflows make it the ideal
successor to the venerable [setuptools](http://setuptools.readthedocs.io). It is
similar to `npm` and `yarn` in the JavaScript world, and other modern package
and dependency managers.

With Poetry 1.0 [around the
corner](https://github.com/sdispater/poetry/projects/1), I would recommend you
install the *preview* version of Poetry:

```sh
curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py |
POETRY_PREVIEW=1 python
```

Open a new login shell or source `~/.poetry/env` in your current shell:

```sh
source ~/.poetry/env
```

Initialize your Python project:

```sh
poetry init --no-interaction  # short option: -n
```

This command will create a `pyproject.toml` file, the
[new](https://www.python.org/dev/peps/pep-0518/)
[standard](https://www.python.org/dev/peps/pep-0517/) Python package
configuration file.

```toml
[tool.poetry]
name = "hypermodern-python-project"
version = "0.1.0"
description = ""
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.8"

[tool.poetry.dev-dependencies]

[build-system]
requires = ["poetry>=0.12"]
build-backend = "poetry.masonry.api"
```

There you go, one declarative file in [TOML](https://github.com/toml-lang/toml)
syntax, containing the entire package configuration.

Poetry added a dependency on Python 3.8, because this is the Python version you
ran it in. Support the previous release as well by changing this to Python 3.7:

```toml
[tool.poetry.dependencies]
python = "^3.7"
```

## Managing dependencies with Poetry

Let's install the first dependency, the
[click](https://click.palletsprojects.com/) package. This Python package allows
you to create beautiful command-line interfaces in a composable way with as
little code as necessary.

```sh
poetry add click
```

Several things are happening here:

- Poetry creates a virtualenv for the project
- The dependency on `click` is added to the `pyproject.toml` file
- Poetry creates a so-called *lock file*, aptly named `poetry.lock`
- The dependency is downloaded and installed into the virtualenv

The dependency entry for `click` in `pyproject.toml` contains the [version
constraint](https://poetry.eustace.io/docs/versions/) `^7.0`. In
[SemVer](https://semver.org/) terms, this allows upgrades to minor and patch
releases only. Major releases are assumed to contain breaking changes, and
require an explicit update of the `pyproject.toml` file.

Upgrading your dependency -- within the limits of the version contraint -- is as
easy as this:

```sh
poetry update click
```

By contrast, `poetry.lock` contains the exact version of `click` installed into
the virtualenv. Place this file under source control. It allows everybody in
your team to work with the same environment. It also enables you to install the
same dependencies into a production environment that were used during
development ([dev/prod parity](https://12factor.net/dev-prod-parity)).

Let's run a Python session inside the new virtualenv:

```python
$ poetry run python
Python 3.8.0 (default, Oct 16 2019, 19:27:04)
[GCC 8.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import click
>>> click.__version__
'7.0'
>>>
```

## Creating a command-line interface with click

Time to add some actual code to the package. As you may have guessed, we're
going to create a console application with `click`. Organize your package in
[src layout](https://hynek.me/articles/testing-packaging/), like this:

```sh
src
└── hypermodern_python_project
    ├── __init__.py
    └── console.py

2 directories, 2 files
```

Use [snake-case](https://en.wikipedia.org/wiki/Snake_case) for the package name
(`hypermodern_python_project`), as opposed to the
[kebab-case](https://en.wiktionary.org/wiki/kebab_case) used for the repository
name (`hypermodern-python-project`). In other words, replace hyphens by
underscores. Without further ado, here's the full Python code for our package:

```python
# src/hypermodern_python_project/__init__.py
__version__ = "0.1.0"

# src/hypermodern_python_project/console.py
import click

from . import __version__


@click.command()
@click.version_option(version=__version__)
def main():
    """The hypermodern Python project."""
```

The `console` module defines a minimal command-line application. The script
supports `--help` and `--version` options.

Register the script in `pyproject.toml`:

```toml
[tool.poetry.scripts]
hypermodern-python-project = "hypermodern_python_project.console:main"
```

Finally, install the package into the virtualenv:

```sh
poetry install
```

You can now run the script like this:

```sh
poetry run hypermodern-python-project  # this doesn't do anything useful yet
```

Alternatively, you can use `poetry shell` to spawn a shell inside the
virtualenv:

```sh
$ poetry shell
Spawning shell within …/hypermodern-python-project-zCJBsYTX-py3.8

(venv) $ hypermodern-python-project --help
Usage: hypermodern-python-project [OPTIONS]

  The hypermodern Python project.

Options:
  --version  Show the version and exit.
  --help     Show this message and exit.

(venv) $ hypermodern-python-project --version
hypermodern-python-project, version 0.1.0

(venv) $ exit
```

## Adding unit tests with pytest

It's never too early to add tests to a project. While the
[unittest](https://docs.python.org/3/library/unittest.html) framework is part of
the Python standard library, [pytest](https://docs.pytest.org/en/latest/) has
become somewhat of a *de facto* standard. Let's add this package as a
development dependency:

```sh
poetry add --dev pytest
```

Organize tests in a separate file hierarchy next to `src`, named `tests`:

```sh
tests
├── __init__.py
└── test_console.py

1 directory, 2 files
```

The file `__init__.py` is empty and serves to declare the test suite as a
package. `test_console.py` contains a test case for the `console` module, as
well as a test fixture:

```python
# tests/test_console.py
import click.testing
import pytest

from hypermodern_python_project import console


@pytest.fixture
def runner():
    return click.testing.CliRunner()


def test_help_succeeds(runner):
    result = runner.invoke(console.main, ["--help"])
    assert result.exit_code == 0
```

Invoke pytest to run the test suite:

```python
$ poetry run pytest
============================ test session starts =============================
platform linux -- Python 3.8.0, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /hypermodern-python-project
collected 1 item

tests/test_console.py .                                                 [100%]

============================= 1 passed in 0.03s ==============================
```

## Measuring code coverage with coverage.py

[Coverage.py](https://coverage.readthedocs.io/) is a tool for measuring code
coverage of Python programs. Install it via the
[pytest-cov](https://pytest-cov.readthedocs.io/en/latest/) plugin, which
integrates `coverage.py` with `pytest`:

```sh
poetry add --dev pytest-cov
```

Create the `.coveragerc` configuration file to
teach the tool about your source tree layout. The configuration also enables
branch analysis and the display of line numbers for missing coverage.

```ini
# .coveragerc
[paths]
source =
   src
   */site-packages

[run]
branch = true
source = hypermodern_python_project

[report]
show_missing = true
```

To enable coverage reporting, invoke `pytest` with the `--cov` option:

```python
$ poetry run pytest --cov
============================ test session starts =============================
platform linux -- Python 3.8.0, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /hypermodern-python-project
plugins: cov-2.8.1
collected 1 item

tests/test_console.py .                                                 [100%]

----------- coverage: platform linux, python 3.8.0-final-0 -----------
Name                                         Stmts   Miss Branch BrPart  Cover   Missing
----------------------------------------------------------------------------------------
src/hypermodern_python_project/__init__.py       1      0      0      0   100%
src/hypermodern_python_project/console.py        5      0      0      0   100%
----------------------------------------------------------------------------------------
TOTAL                                            6      0      0      0   100%
============================= 1 passed in 0.09s ==============================
```

## Using nox for test automation

One of my personal favorites, [nox](https://nox.thea.codes/) is a successor to
the venerable [tox](https://tox.readthedocs.io/). At its core, the tool
automates testing in multiple Python environments. It makes it easy to run any
kind of job in an isolated environment, with only those dependencies installed
that the particular job needs.

Install Nox via [pip](https://pip.readthedocs.org/):

```sh
pip install --user --upgrade nox
```

Unlike tox, Nox uses a standard Python file for configuration:

```python
# noxfile.py
import nox


@nox.session(python=["3.8", "3.7"])
def tests(session):
    """Run the test suite."""
    env = {"VIRTUAL_ENV": session.virtualenv.location}
    session.run("poetry", "install", external=True, env=env)
    session.run("pytest", "--cov", *session.posargs)
```

This file defines a session named `tests`, which installs the project
dependencies and runs the test suite. Nox will create a virtualenv for each of
the listed Python versions (3.8 and 3.7), and run the session inside each
virtualenv.

> [This PR](https://github.com/theacodes/nox/pull/245) relieves the need to
> explicitly pass `VIRTUAL_ENV` to Poetry. It has been merged into master and
> will be available with the upcoming Nox release.

```python
$ nox

nox > Running session tests-3.8
nox > Creating virtual environment (virtualenv) using python3.8 in .nox/tests-3-8
nox > poetry install
...
nox > pytest --cov
...
nox > Session tests-3.8 was successful.
nox > Running session tests-3.7
nox > Creating virtual environment (virtualenv) using python3.7 in .nox/tests-3-7
nox > poetry install
...
nox > pytest --cov
...
nox > Session tests-3.7 was successful.
nox > Ran multiple sessions:
nox > * tests-3.8: success
nox > * tests-3.7: success
```

Nox recreates the virtualenv from scratch at each invocation (a sensible
default). You can speed things up by passing the `--reuse-existing-virtualenvs
(-r)` option:

```sh
nox -r
```

## Linting with flake8

Unit tests are not the only tool to help you avoid bugs. Linters analyze source
code to flag programming errors, bugs, stylistic errors, and suspicious
constructs. The most common ones for Python are [pylint](https://www.pylint.org)
and [flake8](http://flake8.pycqa.org). We opt for the latter due to its ease of
setup and use.

In addition, install two rather useful flake8 plugins: The
[flake8-bugbear](https://pypi.org/project/flake8-bugbear/) plugin helps you find
bugs and design problems in your program. The
[flake8-import-order](https://github.com/PyCQA/flake8-import-order) plugin
checks whether the order of import statements is consistent and [PEP
8](https://www.python.org/dev/peps/pep-0008/#imports)-compliant.

Instead of adding all of these as development dependencies to `pyproject.toml`,
install them inside a Nox linting session. When linting your code, there is no
need to install your project or any of its dependencies (and when running the
test suite, there is no need to install the linter). Add this session to your
`noxfile.py`:

```python
# noxfile.py
import nox


locations = "src", "tests", "noxfile.py"


@nox.session(python="3.7")
def lint(session):
    """Lint using flake8."""
    session.install("flake8", "flake8-bugbear", "flake8-import-order")
    session.run("flake8", *locations)

...
```

Configure `flake8` and friends using the `.flake8` configuration file:

```ini
# .flake8
[flake8]
max-line-length = 80
max-complexity = 10
select = C,E,F,W,B,B9
ignore = E203, E501, W503
application-import-names = hypermodern_python_project,tests
```

This enables Bugbear's opinionated warnings (`B9`) and ignores some warnings
which do not align well with either Bugbear or the Black code formatter (see
below). It also enables [complexity
checks](https://en.wikipedia.org/wiki/Cyclomatic_complexity) and informs the
`flake8-import-order` plugin about the local package name.

By default, Nox runs all sessions defined in `noxfile.py`, but we can restrict
it to the lint session using the `--session (-s)` option:

```sh
nox -rs lint
```

## Code formatting with Black

The next addition to our toolbox is [Black](https://github.com/psf/black), the
uncompromising Python code formatter. One of its greatest features is its lack
of configurability. Never again lose time to nagging about formatting. Blackened
code looks the same regardless of the project you're reading.

Adding Black is straightforward:

```python
# noxfile.py
...

@nox.session(python="3.8")
def black(session):
    """Run black code formatter."""
    session.install("black")
    session.run("black", *locations)
```

With the Nox session in place, you can reformat your code like this:

```sh
nox -rs black
```

Also, set `nox.options.sessions` at the top of the `noxfile.py` to exclude Black
from the sessions run by default:

```python
# noxfile.py
import nox


nox.options.sessions = "lint", "tests"
...
```

Instead, let's check adherence to the Black code style as part of the lint
session, without actually performing any formatting. This can be done using the
[flake8-black](https://pypi.org/project/flake8-black/) plugin:

```python
# noxfile.py
...
    session.install("flake8", "flake8-bugbear", "flake8-import-order", "flake8-black")
...
```

## Static type checking with pytype

With the advent of [type hints](https://docs.python.org/3/library/typing.html),
several static type checkers for Python have come into existence:
[mypy](http://mypy-lang.org/), Google's
[pytype](https://google.github.io/pytype/), and Microsoft's
[pyright](https://github.com/microsoft/pyright).

Add the following session to `noxfile.py` to add `pytype`:

```python
@nox.session(python="3.7")
def pytype(session):
    """Run the static type checker."""
    session.install("pytype")
    session.run("pytype", "--config=pytype.cfg", *locations)
```

Update `nox.options.session` to include static type checking in the default Nox
sessions:

```python
nox.options.sessions = "lint", "pytype", "tests"
```

Create the `pytype.cfg` configuration file and disable import errors. Some
third-party packages are still distributed without type hints:

```ini
# pytype.cfg
[pytype]
disable = import-error
```

Alternatively, add a `# pytype: disable=import-error` comment to the `import`
statements of offending packages:

```python
# noxfile.py
import nox  # pytype: disable=import-error
...

# tests/test_console.py
import pytest  # pytype: disable=import-error
...
```

## Supporting continuous integration using GitHub Actions

There are many good options when it comes to continuous integration (CI), too
many to list here. What's more, most CI providers have a free plan for
open-source repositories. Traditionally, many open-source projects have used
[Travis CI](https://travis-ci.com). Lately, some have switched to Microsoft's
[Azure Pipelines](https://azure.microsoft.com/en-us/services/devops/pipelines/).

In this tutorial, you are going to use GitHub's own brand new offering, [GitHub
Actions](https://github.com/features/actions). This service is still in a
limited public Beta, which unfortunately means that you need to [sign
up](https://github.com/features/actions) and wait for your invitation.

Configure GitHub Actions by adding the following [YAML](https://yaml.org) file
to the `.github/workflows` directory:

```yaml
# .github/workflows/main.yml
name: tests
on: push
jobs:
  test:
    name: nox
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@1.0.0
    - uses: excitedleigh/setup-nox@0.1.0
    - uses: dschep/install-poetry-action@v1.2
      with:
        preview: true
    - run: nox
```

This workflow is triggered on every push to your GitHub repository, and runs on
the latest supported Ubuntu image. The workflow consists of four steps:

1. Use [actions/checkout](https://github.com/actions/checkout) to fetch and check out the version that triggered the workflow.
2. Use [excitedleigh/setup-nox](https://github.com/excitedleigh/setup-nox) to activate Python and install Nox.
3. Use [dschep/install-poetry-action](https://github.com/dschep/install-poetry-action) to install Poetry.
4. Invoke `nox` to run your test suite.

What's CI without a nice badge on your GitHub repository page? Add the following
`README.md` file:

```markdown
[![tests](https://github.com/<your-username>/hypermodern-python-project/workflows/tests/badge.svg)](https://github.com/<your-username>/hypermodern-python-project/actions?workflow=tests)

# hypermodern-python-project
```

## Coverage reporting with Codecov

Let's also display a coverage badge on your GitHub repository page. We will use
[Codecov](https://codecov.io/) for this; another common option is
[Coveralls](https://coveralls.io/). Sign up for the free open-source plan,
install the GitHub app, and add your repository to Codecov. The sign up process
will guide you through these steps.

Add the Nox session shown below. This session exports the coverage data to
[cobertura](https://cobertura.github.io/cobertura/) XML format, which is the
format expected by Codecov. It then uses the official
[codecov](https://github.com/codecov/codecov-python) CLI to upload the coverage
data.

```python
# noxfile.py
...

@nox.session(python="3.7")
def coverage(session):
    """Upload coverage data."""
    session.install("coverage", "codecov")
    session.run("coverage", "xml")
    session.run("codecov", *session.posargs)
```

GitHub Actions needs to be granted access to upload to Codecov. On Codecov, copy
the *Repository Upload Token* from the settings page of your repository. On
GitHub, go to the settings page of your repository, and add a secret named
`CODECOV_TOKEN` with the token you just copied.

Invoke the session from the GitHub Actions workflow, providing the
`CODECOV_TOKEN` secret as an environment variable:

```yaml
# .github/workflows/main.yml
name: tests
on: push
jobs:
  test:
    name: nox
    runs-on: ubuntu-latest
    steps:
...
    - run: nox
    - run: nox -e coverage
      env:
        CODECOV_TOKEN: ${{secrets.CODECOV_TOKEN}}
```

Finally, add the Codecov badge to your `README.md`:

```markdown
[![Codecov](https://codecov.io/gh/<your-username>/hypermodern-python-project/branch/master/graph/badge.svg)](https://codecov.io/gh/<your-username>/hypermodern-python-project)
```

## Uploading your package to PyPI

[PyPI](https://pypi.org/) is the official Python package registry, also known by
its affectionate nickname "the Cheeseshop". Uploading your package to PyPI allows
others to install it with [pip](https://pip.readthedocs.org/), like so:

```sh
pip install <your-package>
```

Building and uploading packages with Poetry is simple:

```sh
poetry build
poetry publish
```

Instead of doing this manually, you should automate the release process:

- Build the package on every push, for testing purposes.
- Uploads to PyPI, on the other hand, should only be performed when a Git tag is pushed.

Sign up at PyPI, and generate an access token. This token will permit GitHub
Actions to upload packages to your PyPI account. Go to your repository settings
on GitHub, and add the token as a secret named `PYPI_TOKEN`.

Add the following lines to the bottom of your GitHub workflow:

```yaml
# .github/workflows/main.yml
...
    - run: poetry build
    - if: github.event_name == 'push' && startsWith(github.event.ref, 'refs/tags')
      run: |
        poetry publish --username=__token__ --password=${{ secrets.PYPI_TOKEN }}
```

You can now trigger package uploads by pushing a release tag to GitHub, like
this:

```sh
git tag --message="hypermodern-python-project 1.0.0" v1.0.0
git push --follow-tags
```

Add a badge to your `README.md` which links to your PyPI project page and always
displays the latest release:

```markdown
[![PyPI](https://img.shields.io/pypi/v/hypermodern-python-project.svg)](https://pypi.org/project/hypermodern-python-project/)
```

## A typical release process

Let's walk through the entire process of creating a release. In a nutshell, you
need to perform these steps:

1. Bump the version
2. Update the release notes
3. Add a Git tag

The first step is to bump the version. You can use Poetry to update the version
declared in `pyproject.toml`. Don't forget to also update the version in your
package's `__init__.py`.

```sh
poetry version <version>  # for example: "0.2.1", "major", "minor", "patch"
# now go update src/hypermodern-python-project/__init__.py
```

The second step is to update the release notes. For example, keep a
`CHANGELOG.md` file in your repository, using the format specified at [Keep a
Changelog](https://keepachangelog.com/).

The third step is to create and push an annotated Git tag, as described above.
By convention, these tags have the form `v<version>`.

After pushing the release tag, you can create a [GitHub
release](https://help.github.com/en/articles/creating-releases). If your code
changes come in via Pull Requests (PRs), this can be fully automated using the
[release-drafter](https://github.com/marketplace/actions/release-drafter) GitHub
Action.

## Creating documentation with Sphinx

[Sphinx](http://www.sphinx-doc.org/) is the documentation tool used by the
official Python documentation and many open-source projects. Sphinx
documentation is commonly written using
[reStructuredText](http://docutils.sourceforge.net/rst.html), although Markdown
is also supported. Here is a simple example:

```rst
The hypermodern Python project
==============================

Installation
------------

To install the hypermodern Python project, run this command in your terminal:

.. code-block:: console

   $ pip install hypermodern-python-project

Usage
-----

The hypermodern Python project's usage looks like:

.. code-block:: console

    $ hypermodern-python-project [OPTIONS]

.. option:: --version

    Display the version and exit.

.. option:: --help

    Display a short usage message and exit.
```

Create a directory `docs` and place the above text in a file `index.rst`:

```sh
docs
└── index.rst

1 directory, 1 file
```

Add the following Sphinx configuration file, named `conf.py` to your `docs`
directory:

```python
# docs/conf.py
import sphinx_rtd_theme

project = "hypermodern-python-project"
author = "Your Name"
copyright = f"2019, {author}"
extensions = ["sphinx_rtd_theme"]
html_theme = "sphinx_rtd_theme"
```

The configuration file sets some minimal meta information, and applies the theme
[sphinx-rtd-theme](https://github.com/readthedocs/sphinx_rtd_theme).

Add a Nox session to build the documentation:

```python
@nox.session(python="3.7")
def docs(session):
    """Build the documentation."""
    session.install("sphinx", "sphinx-rtd-theme")
    session.run("sphinx-build", "docs", "docs/_build")
```

Run the Nox session:

```sh
nox -rs docs
```

You can now open the file `docs/_build/index.html` in your browser to view your
documentation offline.

## Hosting documentation at Read the Docs

[Read the Docs](https://readthedocs.org/) hosts documentation for countless
open-source Python projects. It is their theme that you used in the example
above.

Sign up at Read the Docs.


<!--

{{< figure src="http://www.vintagecomputer.net/ctc/3300/CTC_DataPoint-3300_pic3.jpg" caption="Fun fact: Consoles have supported dark mode since 1969, exactly half a century before iOS 13." alt="DataPoint 3300 (1969)" link="https://www.youtube.com/watch?v=dEGlKpIBujc" width="80%" class="centered" >}}

########################################################################


| Tool           | Description            |
| ---            | ---                    |
| Poetry         | package manager        |
| pyenv          | Python version manager |
| nox            | test automation        |
| flake8         | linter                 |
| black          | code formatter         |
| pytype         | static type checker    |
| pytest         | unit tests             |
| coverage       | test coverage          |
| Git            | version control        |
| GitHub         | repository hosting     |
| GitHub Actions | CI                     |
| PyPI           | package hosting        |
| Docker         | container              |
| Heroku         | PaaS                   |
| flask          | web framework          |

-->
