--- 
date: 2019-10-16T09:12:59+02:00
title: "The hypermodern Python project"
description: "Coding in Python like Savielly Tartakower."
draft: true
tags:
  - python
  - poetry
  - nox
---

Welcome to the *tour de force* of the Python ecosystem in late 2019!

Python 3.8 has been officially released this week, and the Python 2 sunset is
scheduled for new year 2020.

The Python landscape has changed drastically over the last decade, with a host
of new tools and best practices improving the Python developer experience. Time
to show how to build a Python project for hypermodernists, from scratch.

This post is aimed both at beginners who are keen to learn best practises from
the start, and seasoned Python developers whose workflows are still determined
by the boilerplate and workarounds associated with the legacy toolbox.

> *You need a recent Linux, Unix, or Mac system with
> [bash](https://www.gnu.org/software/bash/), [curl](https://curl.haxx.se) and
> [git](https://www.git-scm.com) for this tutorial.*

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Installing Python with pyenv](#installing-python-with-pyenv)
- [Setting up a Python project using Poetry](#setting-up-a-python-project-using-poetry)
- [Managing dependencies with Poetry](#managing-dependencies-with-poetry)
- [Creating a command-line interface with click](#creating-a-command-line-interface-with-click)
- [Adding unit tests with pytest](#adding-unit-tests-with-pytest)
- [Measuring code coverage with coverage.py](#measuring-code-coverage-with-coveragepy)
- [Using nox for test automation](#using-nox-for-test-automation)

<!-- markdown-toc end -->
<!--

| Tool           | Description            |
| ---            | ---                    |
| Poetry         | package manager        |
| pyenv          | Python version manager |
| nox            | test automation        |
| flake8         | linter                 |
| black          | code formatter         |
| pytype         | static type checker    |
| pytest         | unit tests             |
| coverage       | test coverage          |
| Git            | version control        |
| GitHub         | repository hosting     |
| GitHub Actions | CI                     |
| PyPI           | package hosting        |
| Docker         | container              |
| Heroku         | PaaS                   |
| flask          | web framework          |

-->

## Setting up a repository on GitHub

Go ahead and create an empty repository on [GitHub](https://github.com). You can
do this on the GitHub website, or entirely from the console, using the excellent
[hub](https://github.com/github/hub) tool:

```sh
mkdir hypermodern-python-project
cd hypermodern-python-project
hub init -g
hub create --description="The hypermodern Python project"
```

{{< figure src="http://www.vintagecomputer.net/ctc/3300/CTC_DataPoint-3300_pic3.jpg" caption="Fun fact: Consoles have supported dark mode since 1969, exactly half a century before iOS 13." alt="DataPoint 3300 (1969)" link="https://www.youtube.com/watch?v=dEGlKpIBujc" width="80%" class="centered" >}}

If you created the repository on the GitHub website, clone the repository to
your machine, and `cd` into it.

```sh
git clone git@github.com:<your-username>/hypermodern-python-project.git
cd hypermodern-python-project
```

As you follow the rest of the tutorial, you are encouraged to create a series of
[small, atomic commits](https://deepsource.io/blog/git-best-practices/) to
document your steps. Use `git status` to discover files generated by the
commands shown in the tutorial. Generally, you should add generated files to the
`.gitignore` file. But in some cases these files should be placed under source
control; this will be pointed out below.

## Installing Python with pyenv

Let's continue by setting up the developer environment. First we need to get a
recent Python. Don't bother with package managers or official binaries. The tool
of choice is [pyenv](https://github.com/pyenv/pyenv), a Python version manager.

Install it like this:

```sh
curl https://pyenv.run | bash
```

Add the following lines to your `~/.bashrc`:

```sh
export PATH="~/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"
```

Open a new shell, or source `~/.bashrc` in your current shell:

```sh
source ~/.bashrc
```

Install the Python build dependencies for your platform, using one of the
commands listed in the [official
instructions](https://github.com/pyenv/pyenv/wiki/Common-build-problems). For
example, on a recent Ubuntu this would be:

```sh
sudo apt update && sudo apt install -y make build-essential libssl-dev zlib1g-dev \
libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev \
libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python-openssl git
```

You're ready to install the latest Python releases. This may take a while:

```sh
pyenv install 3.8.0
pyenv install 3.7.5
```

Make your fresh Pythons available inside the repository:

```sh
pyenv local 3.8.0 3.7.5
```

Congratulations! You have access to the latest and greatest of Python:

```sh
$ python --version
Python 3.8.0

$ python3.7 --version
Python 3.7.5
```

## Setting up a Python project using Poetry

[Poetry](https://poetry.eustace.io) is a tool to manage Python packaging and
dependencies. It's ease of use and support for modern workflows make it the
ideal successor to the venerable [setuptools](http://setuptools.readthedocs.io).
It is similar to `npm` and `yarn` in the JavaScript world, and other modern
package and dependency managers.

With [Poetry 1.0](https://github.com/sdispater/poetry/projects/1) around the
corner, I would recommend you to install the *preview version* of Poetry:

```sh
curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py |
POETRY_PREVIEW=1 python
```

Open a new login shell or source `~/.poetry/env` in your current shell:

```sh
source ~/.poetry/env
```

Initialize your Python project:

```sh
poetry init --no-interaction  # short option: -n
```

This command will create a `pyproject.toml` file, the
[new](https://www.python.org/dev/peps/pep-0518/)
[standard](https://www.python.org/dev/peps/pep-0517/) Python package
configuration file.

```toml
[tool.poetry]
name = "hypermodern-python-project"
version = "0.1.0"
description = ""
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.8"

[tool.poetry.dev-dependencies]

[build-system]
requires = ["poetry>=0.12"]
build-backend = "poetry.masonry.api"
```

There you go, one declarative file in [TOML](https://github.com/toml-lang/toml)
syntax, containing the entire package configuration.

Poetry added a dependency on Python 3.8, because this is the Python version it
was running in. Support the older release as well by changing this to Python
3.7:

```toml
[tool.poetry.dependencies]
python = "^3.7"
```

## Managing dependencies with Poetry

Let's install the first dependency, the
[click](https://click.palletsprojects.com/) package. This Python package allows
you to create beautiful command line interfaces in a composable way with as
little code as necessary.

```sh
poetry add click
```

Several things are happening here:

- Poetry creates a virtualenv for the project
- The dependency on `click` is added to the `pyproject.toml` file
- Poetry creates a so-called *lock file*, aptly named `poetry.lock`
- The dependency is downloaded and installed into the virtualenv

The dependency entry for `click` in `pyproject.toml` contains the [version
constraint](https://poetry.eustace.io/docs/versions/) `^7.0`. In
[SemVer](https://semver.org/) terms, this allows upgrades to minor and patch
releases only. Major releases are assumed to contain breaking changes, and
require an explicit update of the `pyproject.toml` file.

Upgrading your dependency -- within the limits of the version contraint -- is as
easy as this:

```sh
poetry update click
```

By contrast, the lock file `poetry.lock` contains the exact version of `click`
installed into the virtualenv. This file should be placed under source control.
It allows everybody in your team to work with the same environment. Just as
importantly, it enables you to install the exact dependencies into a production
environment that were used during development and testing (aka [dev/prod
parity](https://12factor.net/dev-prod-parity)).

Let's run a Python session inside the new virtualenv:

```python
$ poetry run python
Python 3.8.0 (default, Oct 16 2019, 19:27:04)
[GCC 8.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import click
>>> click.__version__
'7.0'
>>>
```

## Creating a command-line interface with click

Time to add some actual code to the package. As you may have guessed, we're
going to create a console application with `click`. Organize your package in
[`src` layout](https://hynek.me/articles/testing-packaging/), like this:

```sh
src
└── hypermodern_python_project
    ├── __init__.py
    └── console.py

2 directories, 2 files
```

Use [snake-case](https://en.wikipedia.org/wiki/Snake_case) for the package name
(`hypermodern_python_project`), as opposed to the
[kebab-case](https://en.wiktionary.org/wiki/kebab_case) used for the repository
name (`hypermodern-python-project`). In other words, convert hyphens to
underscores. Without further ado, here's the full Python code for our package:

```python
# src/hypermodern_python_project/__init__.py
__version__ = "0.1.0"

# src/hypermodern_python_project/console.py
import click

from . import __version__


@click.command()
@click.version_option(version=__version__)
def main():
    """The hypermodern Python project."""
```

The `console` module defines a minimal command-line application. The script
supports `--help` and `--version` options.

Register the script in `pyproject.toml`:

```toml
[tool.poetry.scripts]
hypermodern-python-project = "hypermodern_python_project.console:main"
```

Finally, install the package into the virtualenv:

```sh
poetry install
```

You could now use `poetry run` with the name of the script. Instead, let's use
`poetry shell` to spawn a shell inside the virtualenv:

```sh
$ poetry shell
Spawning shell within …/hypermodern-python-project-zCJBsYTX-py3.8

(venv) $ hypermodern-python-project --help
Usage: hypermodern-python-project [OPTIONS]

  The hypermodern Python project.

Options:
  --version  Show the version and exit.
  --help     Show this message and exit.

(venv) $ hypermodern-python-project --version
hypermodern-python-project, version 0.1.0

(venv) $ exit
```

## Adding unit tests with pytest

It's never too early to add tests to a project. While the
[unittest](https://docs.python.org/3/library/unittest.html) framework is part of
the Python standard library, [pytest](https://docs.pytest.org/en/latest/) has
become somewhat of a *de facto* standard. Let's add this package as a
development dependency:

```sh
poetry add --dev pytest
```

Organize tests in a separate file hierarchy next to `src`, named `tests`:

```sh
tests
├── __init__.py
└── test_console.py

1 directory, 2 files
```

`__init__.py` is just an empty file. `test_console.py` contains a test fixture
and a test case for the `console` module:

```python
# tests/test_console.py
import click.testing
import pytest

from hypermodern_python_project import console


@pytest.fixture
def runner():
    return click.testing.CliRunner()


def test_help_succeeds(runner):
    result = runner.invoke(console.main, ["--help"])
    assert result.exit_code == 0
```

Invoke pytest to run the test suite:

```python
$ poetry run pytest
============================ test session starts =============================
platform linux -- Python 3.8.0, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /hypermodern-python-project
collected 1 item

tests/test_console.py .                                                 [100%]

============================= 1 passed in 0.03s ==============================
```

## Measuring code coverage with coverage.py

[Coverage.py](https://coverage.readthedocs.io/) is a tool for measuring code
coverage of Python programs. Install it via the
[pytest-cov](https://pytest-cov.readthedocs.io/en/latest/) plugin, which
integrates `coverage.py` with `pytest`:

```sh
poetry add --dev pytest-cov
```

Create the `.coveragerc` configuration file to
teach the tool about your source tree layout. The configuration also enables
branch analysis and the display of line numbers for missing coverage.

```ini
# .coveragerc
[paths]
source =
   src
   */site-packages

[run]
branch = true
source = hypermodern_python_project

[report]
show_missing = true
```

To enable coverage reporting, invoke `pytest` with the `--cov` option:

```python
$ poetry run pytest --cov
============================ test session starts =============================
platform linux -- Python 3.8.0, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
rootdir: /hypermodern-python-project
plugins: cov-2.8.1
collected 1 item

tests/test_console.py .                                                 [100%]

----------- coverage: platform linux, python 3.8.0-final-0 -----------
Name                                         Stmts   Miss Branch BrPart  Cover   Missing
----------------------------------------------------------------------------------------
src/hypermodern_python_project/__init__.py       1      0      0      0   100%
src/hypermodern_python_project/console.py        5      0      0      0   100%
----------------------------------------------------------------------------------------
TOTAL                                            6      0      0      0   100%
============================= 1 passed in 0.09s ==============================
```

## Using nox for test automation

One of my personal favorites, [nox](https://nox.thea.codes/) is a successor to
the venerable [tox](https://tox.readthedocs.io/). At its core, the tool
automates testing in multiple Python environments. It makes it easy to run any
kind of job in an isolated environment, with only those dependencies installed
that the particular job needs.

Install Nox via [pip](https://pip.readthedocs.org/):

```sh
pip install --user --upgrade nox
```

Unlike tox, Nox uses a standard Python file for configuration:

```python
# noxfile.py
import nox


@nox.session(python=["3.8", "3.7"])
def tests(session):
    """Run the test suite."""
    env = {"VIRTUAL_ENV": session.virtualenv.location}
    session.run("poetry", "install", external=True, env=env)
    session.run("pytest", "--cov", *session.posargs)
```

This file defines a session named `tests`, which installs the project
dependencies and runs the test suite. Nox will create a virtualenv for each of
the listed Python versions (3.8 and 3.7), and run the session inside each
virtualenv.

> This [PR](https://github.com/theacodes/nox/pull/245) relieves the need to
> explicitly pass `VIRTUAL_ENV` to Poetry. It has been merged into master and
> will be available with the upcoming Nox release.

```python
$ nox

nox > Running session tests-3.8
nox > Creating virtual environment (virtualenv) using python3.8 in .nox/tests-3-8
nox > poetry install
...
nox > pytest --cov
...
nox > Session tests-3.8 was successful.
nox > Running session tests-3.7
nox > Creating virtual environment (virtualenv) using python3.7 in .nox/tests-3-7
nox > poetry install
...
nox > pytest --cov
...
nox > Session tests-3.7 was successful.
nox > Ran multiple sessions:
nox > * tests-3.8: success
nox > * tests-3.7: success
```

Nox recreates the virtualenv from scratch at each invocation (a sensible
default). You can speed things up by passing the `--reuse-existing-virtualenvs
(-r)` option:

```sh
nox -r
```

## Linting with flake8

Unit tests are not the only tool to help you avoid bugs. Linters analyze source
code to flag programming errors, bugs, stylistic errors, and suspicious
constructs. The most common ones for Python are [pylint](https://www.pylint.org)
and [flake8](http://flake8.pycqa.org). We opt for the latter due to its ease of
setup and use.

In addition, install two rather useful flake8 plugins: The
[flake8-bugbear](https://pypi.org/project/flake8-bugbear/) plugin helps you find
bugs and design problems in your program. The
[flake8-import-order](https://github.com/PyCQA/flake8-import-order) plugin
checks the [order of import
statements](https://www.python.org/dev/peps/pep-0008/#imports).

Instead of adding all of these as development dependencies to `pyproject.toml`,
install them inside a Nox linting session. When linting your code, there is no
need to install your project or any of its dependencies (and when running the
test suite, there is no need to install the linter). Add this session to your
`noxfile.py`:

```python
# noxfile.py
import nox


locations = "src", "tests", "noxfile.py"


@nox.session(python="3.7")
def lint(session):
    """Lint using flake8."""
    session.install("flake8", "flake8-bugbear", "flake8-import-order")
    session.run("flake8", *locations)


@nox.session(python=["3.8", "3.7"])
def tests(session):
    """Run the test suite."""
    ...
```

Configure `flake8` and friends using the `.flake8` configuration file:

```ini
# .flake8
[flake8]
max-line-length = 80
max-complexity = 10
select = C,E,F,W,B,B9
ignore = E203, E501, W503
application-import-names = hypermodern_python_project,tests
```

This enables Bugbear's opinionated warnings (`B9`) and ignores some warnings
which do not align well with either Bugbear or the Black code formatter (see
below). It also enables [complexity
checks](https://en.wikipedia.org/wiki/Cyclomatic_complexity) and informs the
`flake8-import-order` plugin about the local package name.

By default, Nox runs all sessions defined in `noxfile.py`, but we can restrict
it to the lint session using the `--session (-s)` option:

```sh
nox -rs lint
```

## Code formatting with Black

The next part of our toolbox is [Black](https://github.com/psf/black), the
uncompromising Python code formatter. One of its greatest features is its lack
of configurability. Never again lose time to nagging about formatting. Blackened
code looks the same regardless of the project you're reading. Formatting becomes
transparent after a while and you can focus on the content instead.

Adding Black is straightforward:

```python
# noxfile.py
...

@nox.session(python="3.8")
def black(session):
    """Run black code formatter."""
    session.install("black")
    session.run("black", *locations)
```

With the Nox session in place, you can reformat your code like this:

```sh
nox -rs black
```

Also, set `nox.options.sessions` at the top of the `noxfile.py` to exclude Black
from the sessions run by default:

```python
# noxfile.py
import nox


nox.options.sessions = "lint", "tests"
...
```

Instead, let's check adherence to the Black code style as part of the lint
session, without actually performing any formatting. This can be done using the
[flake8-black](https://pypi.org/project/flake8-black/) plugin:

```python
# noxfile.py
...
    session.install("flake8", "flake8-bugbear", "flake8-import-order", "flake8-black")
...
```

<!--

########################################################################

```sh
################ Add GitHub action
mkdir -p .github/workflows
$EDITOR .github/workflows/workflow.yml

################ Add GitHub Action badge
$EDITOR README.md
```

- Sign up at https://codecov.io/
- Install the Codecov GitHub app
- Add repository to Codecov (https://codecov.io/gh/cjolowicz/hypermodern-python-project)
- Add Codecov token to GitHub repository secrets

```sh
$EDITOR .github/workflows/workflow.yml
$EDITOR README.md
################ Add Codecov badge
```

- Sign up at PyPI
- Generate token
- Add token to secrets
-->
